[Back to Contents](README.md)

# Authentication: I am who I say I am

> [!NOTE] 
> Authentication answers the question "Who are you?" while authorization answers "What can you do?"

Authentication is the process of verifying the identity of a user, system, or entity. This chapter covers various authentication methods, from traditional username/password combinations to modern multi-factor authentication systems.

## Table of Contents
- [Form-based Authentication](#form-based-authentication)
- [Basic Authentication](#basic-authentication)
- [Multi-Factor Authentication (MFA)](#multi-factor-authentication-mfa)
- [TOTP and HOTP: Secure 2FA](#totp-and-hotp-secure-2fa)
- [Password Reset Security](#password-reset-security)
- [Session Management](#session-management)
- [Best Practices](#best-practices)

## Form-based Authentication

Form-based authentication is the most common method used in web applications. Users provide credentials (typically username and password) through an HTML form.

### Implementation Considerations

> [!IMPORTANT]
> Never transmit credentials over HTTP. Always use HTTPS for authentication endpoints.

**Secure Form Handling:**
- Always use HTTPS to protect credentials in transit
- Implement proper input validation and sanitization  
- Use CSRF tokens to prevent cross-site request forgery
- Implement rate limiting to prevent brute force attacks

**Example secure login form:**
```html
<form method="POST" action="/login">
  <input type="hidden" name="csrf_token" value="{{csrf_token}}">
  <input type="email" name="email" required>
  <input type="password" name="password" required>
  <button type="submit">Login</button>
</form>
```

**Server-side Implementation:**
```python
# Example in Python/Flask
from flask_limiter import Limiter
import bcrypt

@app.route('/login', methods=['POST'])
@limiter.limit("5 per minute")  # Rate limiting
def login():
    email = request.form.get('email')
    password = request.form.get('password')
    
    # Validate CSRF token
    if not validate_csrf_token(request.form.get('csrf_token')):
        return abort(403)
    
    # Find user and verify password
    user = User.query.filter_by(email=email).first()
    if user and bcrypt.checkpw(password.encode('utf-8'), user.password_hash):
        session['user_id'] = user.id
        return redirect('/dashboard')
    
    return render_template('login.html', error='Invalid credentials')
```

### Common Vulnerabilities

1. **Credential Stuffing**: Attackers use previously breached credentials
2. **Brute Force Attacks**: Systematic attempts to guess passwords
3. **Session Fixation**: Attacker fixes a user's session ID
4. **Timing Attacks**: Differences in response time reveal information

## Basic Authentication

Basic Authentication is a simple HTTP authentication scheme where credentials are sent in the Authorization header.

### How it Works

1. Client requests a protected resource
2. Server responds with `401 Unauthorized` and `WWW-Authenticate: Basic realm="..."`
3. Client sends credentials as Base64-encoded string: `Authorization: Basic <base64(username:password)>`

### Security Considerations

**Strengths:**
- Simple to implement
- Supported by all browsers and HTTP clients
- No session management required

**Weaknesses:**
- Credentials sent with every request
- Base64 is encoding, not encryption
- Vulnerable to man-in-the-middle attacks without HTTPS
- No logout mechanism
- Credentials cached by browser

**Best Practices:**
- Only use over HTTPS
- Implement proper access controls
- Consider using API keys instead for APIs
- Implement rate limiting

## Multi-Factor Authentication (MFA)

Multi-Factor Authentication adds additional security layers beyond passwords. It's based on three factors:

1. **Something you know** (password, PIN)
2. **Something you have** (phone, hardware token)
3. **Something you are** (biometrics)

### Types of Second Factors

**SMS-based (Not Recommended):**
- Vulnerable to SIM swapping
- Interceptable via SS7 protocol attacks
- Phishing-resistant: No

**Time-based One-Time Passwords (TOTP):**
- Generated by authenticator apps
- Based on shared secret and current time
- More secure than SMS
- Phishing-resistant: Partially

**Hardware Security Keys:**
- Physical devices (YubiKey, Titan Key)
- Most secure option
- Phishing-resistant: Yes

**Push Notifications:**
- Sent to mobile apps
- User approves/denies login attempts
- Convenient but can be susceptible to notification fatigue

### Implementation Example

```python
import pyotp
import qrcode
from io import BytesIO
import base64

def setup_totp(user):
    # Generate secret key
    secret = pyotp.random_base32()
    user.totp_secret = secret
    
    # Generate QR code for setup
    totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
        name=user.email,
        issuer_name="Your App Name"
    )
    
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(totp_uri)
    qr.make(fit=True)
    
    img = qr.make_image(fill_color="black", back_color="white")
    buffer = BytesIO()
    img.save(buffer, format='PNG')
    qr_code_data = base64.b64encode(buffer.getvalue()).decode()
    
    return qr_code_data

def verify_totp(user, token):
    totp = pyotp.TOTP(user.totp_secret)
    return totp.verify(token, valid_window=1)  # Allow 30s window
```

## TOTP and HOTP: Secure 2FA

### Time-based One-Time Password (TOTP)

TOTP generates codes based on:
- Shared secret between client and server
- Current Unix timestamp
- Typically 30-second intervals

**Algorithm:**
```
TOTP = HOTP(secret, floor(current_time / time_step))
```

### HMAC-based One-Time Password (HOTP)

HOTP generates codes based on:
- Shared secret
- Counter value
- Incremented with each use

**Security Benefits:**
- Codes expire quickly (TOTP) or are single-use (HOTP)
- Resistant to replay attacks
- Work offline
- Standardized (RFC 4226, RFC 6238)

### Implementation Best Practices

```python
class TOTPManager:
    def __init__(self, secret, time_step=30, digits=6):
        self.secret = secret
        self.time_step = time_step
        self.digits = digits
    
    def generate_code(self, timestamp=None):
        if timestamp is None:
            timestamp = time.time()
        
        time_counter = int(timestamp // self.time_step)
        return pyotp.HOTP(self.secret).at(time_counter)
    
    def verify_code(self, code, timestamp=None, valid_window=1):
        if timestamp is None:
            timestamp = time.time()
        
        time_counter = int(timestamp // self.time_step)
        
        # Check current and adjacent time windows
        for i in range(-valid_window, valid_window + 1):
            if pyotp.HOTP(self.secret).at(time_counter + i) == code:
                return True
        return False
```

## Password Reset Security

Password reset is often the weakest link in authentication systems. Implement it securely:

### Secure Reset Process

1. **Generate cryptographically secure reset token**
2. **Set reasonable expiration time** (15-30 minutes)
3. **Invalidate token after use**
4. **Rate limit reset requests**
5. **Don't reveal whether email exists**

### Implementation Example

```python
import secrets
import hashlib
from datetime import datetime, timedelta

def generate_reset_token():
    return secrets.token_urlsafe(32)

def request_password_reset(email):
    user = User.query.filter_by(email=email).first()
    
    if user:
        # Generate secure token
        token = generate_reset_token()
        
        # Store hashed token (don't store plaintext)
        user.reset_token_hash = hashlib.sha256(token.encode()).hexdigest()
        user.reset_token_expires = datetime.utcnow() + timedelta(minutes=15)
        
        # Send email with token
        send_reset_email(email, token)
    
    # Always return same response to prevent email enumeration
    return "If the email exists, a reset link has been sent."

def reset_password(token, new_password):
    token_hash = hashlib.sha256(token.encode()).hexdigest()
    
    user = User.query.filter_by(reset_token_hash=token_hash).first()
    
    if user and user.reset_token_expires > datetime.utcnow():
        # Reset password
        user.password_hash = bcrypt.hashpw(new_password.encode(), bcrypt.gensalt())
        
        # Clear reset token
        user.reset_token_hash = None
        user.reset_token_expires = None
        
        # Invalidate all existing sessions
        user.increment_session_version()
        
        return True
    
    return False
```

## Session Management

Proper session management is crucial for maintaining authentication state:

### Session Security Best Practices

1. **Generate cryptographically secure session IDs**
2. **Regenerate session ID after login**
3. **Set appropriate session timeout**
4. **Implement proper logout**
5. **Use secure session storage**

### Secure Session Implementation

```python
import secrets
from datetime import datetime, timedelta

class SessionManager:
    def __init__(self, redis_client):
        self.redis = redis_client
        self.session_timeout = timedelta(hours=2)
    
    def create_session(self, user_id):
        session_id = secrets.token_urlsafe(32)
        session_data = {
            'user_id': user_id,
            'created_at': datetime.utcnow().isoformat(),
            'last_activity': datetime.utcnow().isoformat()
        }
        
        # Store session with expiration
        self.redis.setex(
            f"session:{session_id}",
            int(self.session_timeout.total_seconds()),
            json.dumps(session_data)
        )
        
        return session_id
    
    def validate_session(self, session_id):
        session_data = self.redis.get(f"session:{session_id}")
        
        if not session_data:
            return None
        
        session_data = json.loads(session_data)
        
        # Update last activity
        session_data['last_activity'] = datetime.utcnow().isoformat()
        self.redis.setex(
            f"session:{session_id}",
            int(self.session_timeout.total_seconds()),
            json.dumps(session_data)
        )
        
        return session_data
    
    def destroy_session(self, session_id):
        self.redis.delete(f"session:{session_id}")
```

## Best Practices

### Authentication Security Checklist

1. **Password Security:**
   - Use strong password hashing (Argon2id, scrypt, or bcrypt)
   - Implement password complexity requirements
   - Check against known breached passwords
   - Implement password history

2. **Rate Limiting:**
   - Limit login attempts per IP/user
   - Implement exponential backoff
   - Use CAPTCHA after failed attempts
   - Monitor for suspicious patterns

3. **Session Management:**
   - Use secure, random session IDs
   - Implement proper session timeout
   - Regenerate session ID after login
   - Provide secure logout functionality

4. **Multi-Factor Authentication:**
   - Implement MFA for sensitive operations
   - Support multiple MFA methods
   - Provide backup codes
   - Consider risk-based authentication

5. **Monitoring and Logging:**
   - Log authentication events
   - Monitor for suspicious activity
   - Implement alerting for security events
   - Regular security audits

### Common Pitfalls to Avoid

1. **Storing passwords in plaintext**
2. **Using weak hashing algorithms (MD5, SHA1)**
3. **Not implementing rate limiting**
4. **Revealing information in error messages**
5. **Not validating session tokens properly**
6. **Using predictable session IDs**
7. **Not implementing proper logout**
8. **Ignoring password reset security**

### Security Headers for Authentication

```http
# Protect authentication cookies
Set-Cookie: session_id=abc123; Secure; HttpOnly; SameSite=Strict

# Prevent credential sniffing
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

# Prevent XSS attacks on login pages
Content-Security-Policy: default-src 'self'; script-src 'self'

# Prevent clickjacking
X-Frame-Options: DENY
```

## Conclusion

Authentication is the foundation of application security. Implement multiple layers of protection, use proven cryptographic methods, and regularly audit your authentication systems. Remember that security is not just about preventing unauthorized access, but also about providing a good user experience while maintaining strong security controls.

The next chapter will cover [Authorization: What am I allowed to do?](authorization.md) - determining what authenticated users can access.